use thiserror::Error;

use alloy::{
    primitives::{Address, Bytes, FixedBytes},
    rpc::types::Log,
};

use sqlx::{
    prelude::FromRow,
    types::{BigDecimal, chrono},
};

#[derive(Debug, Error)]
pub enum EVMLogsError {
    #[error("Failed to create a valid log data")]
    InvalidLogData,

    #[error("Invalid block number: `{0}`")]
    InvalidBlockNumber(String),
}

#[derive(Debug, Clone, FromRow)]
pub struct EVMLogs {
    pub id: i32,
    pub block_number: BigDecimal,
    pub block_hash: [u8; 32],
    pub address: [u8; 20],
    pub transaction_hash: [u8; 32],
    pub data: Vec<u8>,
    pub event_signature: [u8; 32],
    pub topics: Vec<[u8; 32]>,
    pub transaction_index: i64,
    pub log_index: i64,
    pub removed: bool,
    pub created_at: chrono::NaiveDateTime,
}

/// Convert EVMLogs (from database) to Alloy Log (for processing)
impl TryFrom<EVMLogs> for Log {
    type Error = EVMLogsError;

    fn try_from(evm_log: EVMLogs) -> Result<Log, Self::Error> {
        // Convert fixed arrays to Alloy types
        let transaction_hash = FixedBytes::<32>::from(evm_log.transaction_hash);
        let block_hash = FixedBytes::<32>::from(evm_log.block_hash);
        let contract_address = Address::from(evm_log.address);

        // Convert topics
        let topics: Vec<FixedBytes<32>> = evm_log
            .topics
            .iter()
            .map(|t| FixedBytes::<32>::from(*t))
            .collect();

        // Convert data
        let data = Bytes::from(evm_log.data);

        // Create inner log (the actual primitives::Log)
        let inner = alloy::primitives::Log::new(contract_address, topics, data)
            .ok_or(EVMLogsError::InvalidLogData)?;

        // Parse block number from BigDecimal to u64
        let block_number = evm_log
            .block_number
            .to_string()
            .parse::<u64>()
            .map_err(|_| EVMLogsError::InvalidBlockNumber(evm_log.block_number.to_string()))?;

        // Construct the RPC Log
        Ok(Log {
            inner,
            block_number: Some(block_number),
            block_hash: Some(block_hash),
            block_timestamp: None,
            transaction_hash: Some(transaction_hash),
            transaction_index: Some(evm_log.transaction_index as u64),
            log_index: Some(evm_log.log_index as u64),
            removed: evm_log.removed,
        })
    }
}

/// Convert Alloy Log (from RPC) to EVMLogs (for database storage)
impl TryFrom<Log> for EVMLogs {
    type Error = EVMLogsError;

    fn try_from(log: Log) -> Result<Self, Self::Error> {
        // Extract required fields with error handling
        let address: [u8; 20] = log.address().0.into();

        let transaction_hash: [u8; 32] = log
            .transaction_hash
            .ok_or(EVMLogsError::InvalidLogData)?
            .0
            .into();

        let block_hash: [u8; 32] = log.block_hash.ok_or(EVMLogsError::InvalidLogData)?.0.into();

        let block_number = log.block_number.ok_or(EVMLogsError::InvalidLogData)?;

        // Convert topics
        let topics: Vec<[u8; 32]> = log.topics().iter().map(|t| t.0.into()).collect();

        // First topic is the event signature
        let event_signature = topics.first().copied().unwrap_or([0u8; 32]);

        // Build EVMLogs
        Ok(Self {
            id: 0, // Auto-generated by database
            block_number: BigDecimal::from(block_number),
            block_hash,
            address,
            transaction_hash,
            data: log.data().data.to_vec(),
            event_signature,
            topics,
            transaction_index: log.transaction_index.unwrap_or(0) as i64,
            log_index: log.log_index.unwrap_or(0) as i64,
            removed: log.removed,
            created_at: chrono::Utc::now().naive_utc(),
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_round_trip_conversion() {
        // Create a mock RPC Log
        let address = Address::from([1u8; 20]);
        let topics = vec![FixedBytes::<32>::from([2u8; 32])];
        let data = Bytes::from(vec![3u8; 64]);

        let inner = alloy::primitives::Log::new(address, topics.clone(), data.clone())
            .expect("Should create valid log");

        let rpc_log = Log {
            inner,
            block_number: Some(12345),
            block_hash: Some(FixedBytes::<32>::from([4u8; 32])),
            block_timestamp: None,
            transaction_hash: Some(FixedBytes::<32>::from([5u8; 32])),
            transaction_index: Some(1),
            log_index: Some(2),
            removed: false,
        };

        // Convert to EVMLogs
        let evm_log: EVMLogs = rpc_log
            .clone()
            .try_into()
            .expect("Should convert to EVMLogs");

        // Convert back to Log
        let converted_log: Log = evm_log.try_into().expect("Should convert back to Log");

        // Verify key fields match
        assert_eq!(converted_log.address(), rpc_log.address());
        assert_eq!(converted_log.block_number, rpc_log.block_number);
        assert_eq!(converted_log.transaction_hash, rpc_log.transaction_hash);
    }
}
